<!doctype html><html lang=en data-theme><head><title>| Zxd's Blog</title><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=description content><link rel=stylesheet href=http://zxdfe.github.io/css/style.min.d98386e9809c4644e290afb256e8aad6d2ae6b1aefe82c504efd652e6642708d.css integrity="sha256-2YOG6YCcRkTikK+yVuiq1tKuaxrv6CxQTv1lLmZCcI0=" crossorigin=anonymous type=text/css><link rel=stylesheet href=http://zxdfe.github.io/css/markupHighlight.min.f798cbda9aaa38f89eb38be6414bd082cfd71a6780375cbf67b6d2fb2b96491e.css integrity="sha256-95jL2pqqOPies4vmQUvQgs/XGmeAN1y/Z7bS+yuWSR4=" crossorigin=anonymous type=text/css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><link rel="shortcut icon" href=http://zxdfe.github.iofavicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=http://zxdfe.github.ioapple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=http://zxdfe.github.iofavicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=http://zxdfe.github.iofavicon-16x16.png><link rel=canonical href=http://zxdfe.github.io/><link rel=alternate type=application/rss+xml href=http://zxdfe.github.io/index.xml title="Zxd's Blog"><script type=text/javascript src=http://zxdfe.github.io/js/anatole-header.min.0c05c0a90d28c968a1cad4fb31abd0b8e1264e788ccefed022ae1d3b6f627514.js integrity="sha256-DAXAqQ0oyWihytT7MavQuOEmTniMzv7QIq4dO29idRQ=" crossorigin=anonymous></script><script type=text/javascript src=http://zxdfe.github.io/js/anatole-theme-switcher.min.8ef71e0fd43f21a303733dbbecae5438b791d2b826c68a9883bd7aa459a076d2.js integrity="sha256-jvceD9Q/IaMDcz277K5UOLeR0rgmxoqYg716pFmgdtI=" crossorigin=anonymous></script><meta name=twitter:card content="summary"><meta name=twitter:title content="Zxd's Blog"><meta name=twitter:description content></head><body><div class="sidebar animated fadeInDown"><div class=logo-title><div class=title><img src=http://zxdfe.github.io alt="profile picture"><h3 title><a href=/></a></h3><div class=description><p></p></div></div></div><ul class=social-links></ul><div class=footer><div class=by_farbox>&copy; 2021</div></div></div><div class=main><div class="page-top animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a><ul class=nav id=navMenu><li class=theme-switch-item><a class=theme-switch title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></li></ul></div><div class=autopagerize_page_element><div class=content><div class="post animated fadeInDown"></div><div class="post animated fadeInDown"><div class=post-title><h3><a href=/posts/helloworld/>Helloworld</a></h3></div><div class=post-content><div class=p_part><p>go Blog demo测试一下
哈哈 function(){ console.log("hello world")console.log("hello world")console.log("hello world")console.log("hello world")console.log("hello world")console.log("hello world")console.log("hello world") }</p></div></div><div class=post-footer><div class=meta><div class=info><em class="fas fa-calendar-day"></em><span class=date>Fri, Mar 12, 2021</span></div></div></div></div><div class="post animated fadeInDown"><div class=post-title><h3><a href=/posts/2021-03-05-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/>深浅拷贝</a></h3></div><div class=post-content><div class=p_part><p>拷贝一个很多嵌套的对象怎么实现? 写成怎样的深拷贝才算合格 浅拷贝 创建一个新的对象，来接受要重新复制或引用的对象值。 (只能复制一层)
如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象； 如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，就会影响另一个对象 1. Object.assign() 用于对象的合并 **Object.assign()**** **将源对象（source）的所有可枚举属性，复制到目标对象（target）。它将返回目标对象。 ES6中object的一个方法, 第一个参数是拷贝的目标对象, 后面的参数是拷贝的来源对象(也可以是多个来源) Object.assign(target,...sources)
let target = {} let source = { a: { b : 1 }} Object.assign(target, source) console.log(target) // {a: {b: 1}} const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 } console.</p></div></div><div class=post-footer><div class=meta><div class=info><em class="fas fa-calendar-day"></em><span class=date>Fri, Mar 5, 2021</span></div></div></div></div><div class="post animated fadeInDown"><div class=post-title><h3><a href=/posts/2021-03-03-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/>防抖和节流</a></h3></div><div class=post-content><div class=p_part><p>防抖与节流应用场景 防抖: 事件响应函数(doSomething)在一段时间后(300ms)才执行,如果这段时间内再次调用,则重新计算 在一定的时间间隔内,将多次触发变成一次触发. 防抖应用场景: // setTimeout
Scroll事件滚动触发 // 停止滚动后,判断是否到达页面底部 搜索框输入查询 表单验证 按钮提交事件 浏览器窗口缩放,resize事件 节流: 持续的触发事件,每隔一段时间, 只执行一次; 减少一段时间的触发频率 // 时间戳,定时器
时间戳写法 第一次立即执行 定时器写法 第一次不执行, 最后一次执行 合并 第一次进入立即执行,最后一次也执行 应用
DOM元素的拖拽功能实现,每个一秒干嘛干嘛 射击游戏类,每隔一秒射击 计算鼠标移动距离 监听scroll滚动事件 防抖函数 debounce 1. 普通版本  function debounce(func,delay){ let timerId return function(){ // 每次点击的时候,清楚上一个定时器,重新计时 clearTimeout(timerId) timerId = setTimeout(() => { func.apply(this,arguments) // 如果setTimeout不是箭头函数 }, delay); } } // https://www.30secondsofcode.org/js/s/debounce const debounce = (fn, ms = 0) => { let timeoutId; return function(.</p></div></div><div class=post-footer><div class=meta><div class=info><em class="fas fa-calendar-day"></em><span class=date>Wed, Mar 3, 2021</span></div></div></div></div><div class="post animated fadeInDown"><div class=post-title><h3><a href=/posts/2021-02-28-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9B%B8%E5%85%B3/>EventLoop事件循环</a></h3></div><div class=post-content><div class=p_part><p>为什么JavaScript是单线程的? JavaScript是一门单线程非阻塞的脚本语言, 作为浏览器脚本语言,JavaScript的主要用途是与用户互动，以及操作DOM。
这决定了它只能是单线程，就是同一时间只能做一件事情，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器就不知道以哪个为准了.
任务队列 (Event Queue) 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但这样就太浪费资源了.
怎么解决呢? JS主线程挂起处于等待中的任务, 先运行后面的任务, 再在适当的时候执行这些挂起的任务.
于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
同步任务: 立即执行的任务, 同步任务一般会直接进入到主线程中执行. 只有前一个任务执行完毕，才能执行后一个任务； 异步任务: 异步执行的任务,不进入主线程、而进入"任务队列"（task queue）的任务，如, Ajax网络请求,seTtimeout等定时函数, 异步任务会通过任务队列的机制(先进先出的机制)来进行协调.
事件和回调函数 &ldquo;任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列&rdquo;，就是读取里面有哪些事件。
&ldquo;任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列&rdquo;，等待主线程读取。
所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。
&ldquo;任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&ldquo;任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。
事件循环 Event Loop 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）
同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空后，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。
在事件循环中，每进行一次循环操作称为tick
http://latentflip.com/loupe/ 栈是一种结构化的内存，遵循LIFO（先进后出）的原则 队列也是一种结构化的内存，遵循FIFO（先进先出）的原则
宏任务:
script( 整体代码)、为什么?? setTimeout、 setInterval、 I/O、 UI Render setImmediate(Node.js 环境) 微任务:
promise.then() || catch() Async/Await(实际就是promise) MutaionObserver() process.nextTick(Node.js 环境) 执行一个宏任务&ndash;>清空微任务&ndash;>UI Render ==> 执行一个宏任务&ndash;>清空微任务&ndash;>UI Render (UI Render不一定执行, 是否有UI变动)</p></div></div><div class=post-footer><div class=meta><div class=info><em class="fas fa-calendar-day"></em><span class=date>Sun, Feb 28, 2021</span></div></div></div></div><div class="post animated fadeInDown"><div class=post-title><h3><a href=/posts/%E5%9F%BA%E4%BA%8Ehexo-github-pages%E6%90%AD%E5%BB%BAblog/>基于Hexo+Github Pages搭建blog</a></h3></div><div class=post-content><div class=p_part><p>安装Hexo https://hexo.io/zh-cn/docs/
npm install hexo 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。
$ hexo init &lt;folder> $ cd &lt;folder> $ npm install 启动服务
$ hexo g // hexo generate 生成静态文件 $ hexo s // 启动本地预览服务 修改主题为Next主题 安装主题 Using Git 推荐,可修改模板文件 $ cd hexo-site $ git clone https://github.com/next-theme/hexo-theme-next themes/next Using npm 安装后Theme文件夹下没有主题文件 $ cd hexo-site $ npm install hexo-theme-next 配置主题 hexo/_config.yml theme: next Next文档 https://theme-next.js.org/docs/getting-started/
去掉 Powered by 信息 /themes/(你的主题)/layout/_partials/footer.***
{%- if theme.footer.powered %} &lt;div class="powered-by"> {%- set next_site = 'https://theme-next.</p></div></div><div class=post-footer><div class=meta><div class=info><em class="fas fa-calendar-day"></em><span class=date>Thu, Feb 25, 2021</span></div></div></div></div><div class="post animated fadeInDown"><div class=post-title><h3><a href=/posts/readme/></a></h3></div><div class=post-content><div class=p_part><p>进阶 JS相关 防抖节流 深浅拷贝 EventLoop CSS demo</p></div></div><div class=post-footer><div class=meta><div class=info><em class="fas fa-calendar-day"></em><span class=date>Mon, Jan 1, 0001</span></div></div></div></div><div class=pagination></div></div></div></div><script type=text/javascript src=http://zxdfe.github.io/js/medium-zoom.min.2d6fd0be87fa98f0c9b4dc2536b312bbca48757f584f6ea1f394abc9bcc38fbc.js integrity="sha256-LW/Qvof6mPDJtNwlNrMSu8pIdX9YT26h85SrybzDj7w=" crossorigin=anonymous></script></body></html>