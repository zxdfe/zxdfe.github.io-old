<html><head><meta name=generator content="Hugo 0.81.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=icon href=/images/sun.ico><link rel=stylesheet href=/scss/global.min.4ef81f6d2c60e02adef8b6561af7716f53a29e028e9cb6db104140a555e5edef.css><link rel=stylesheet href=/css/prism.css><link href="https://fonts.googleapis.com/css?family=Merriweather&display=swap" rel=stylesheet><title>Zxd's Blog</title><meta name=description content><meta property="og:title" content="Zxd's Blog"><meta property="og:site_name" content="Zxd's Blog"><meta property="og:description" content><meta property="og:url" content="http://localhost:1313/"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://localhost:1313/uploads/default.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:title content="Zxd's Blog"><link rel=canonical href=http://localhost:1313/><meta name=twitter:description content><meta name=twitter:image content="http://localhost:1313/uploads/default.jpg"><meta property="article:published_time" content="2021-03-20T23:46:00+08:00"><meta property="article:updated_time" content="2021-03-20T23:46:00+08:00"></head><body><script src=/js/initColors.js></script><div class=layout-styled><section class="section fixed-header"><div class=nav-container><a class=back-home href=/><div id=logo-desktop><span class=arrow>←</span>
<span>Home</span></div></a><div class=nav-controls></div></div></section><div id=list-page><section class=item><div><h1 class=title><a href=/posts/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/>基本数据类型</a></h1><div class=date>Mar 20, 2021</div></div><div class=summary>基础类型 undefined Null Boolean String Number Symbol BigInt 引用类型 Object Array RegExp Date Math Function 存储 基础类型存储在栈内存, 被引用或者拷贝时，会创建一个完全相等的变量 引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址 let a = { name: 'Julia', age: 20 } function change(o) { o.age = 24 o = { name: 'Kth', age: 30 } return o } let b = change(a) // 这里没有new console.log(b) // { name: 'Kth', age: 30 } console.log(a) // { name: 'Julia', age: 24 } ps.</div></section><section class=item><div><h1 class=title><a href=/posts/2021-03-05-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/>深浅拷贝</a></h1><div class=date>Mar 5, 2021</div></div><div class=summary>拷贝一个很多嵌套的对象怎么实现? 写成怎样的深拷贝才算合格 浅拷贝 创建一个新的对象，来接受要重新复制或引用的对象值。 (只能复制一层)
如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象； 如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，就会影响另一个对象 1. Object.assign() 用于对象的合并 **Object.assign()**** **将源对象（source）的所有可枚举属性，复制到目标对象（target）。它将返回目标对象。 ES6中object的一个方法, 第一个参数是拷贝的目标对象, 后面的参数是拷贝的来源对象(也可以是多个来源) Object.assign(target,...sources)
let target = {} let source = { a: { b : 1 }} Object.assign(target, source) console.log(target) // {a: {b: 1}} const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 } console.</div></section><section class=item><div><h1 class=title><a href=/posts/2021-03-03-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/>防抖和节流</a></h1><div class=date>Mar 3, 2021</div></div><div class=summary>防抖与节流应用场景 防抖: 事件响应函数(doSomething)在一段时间后(300ms)才执行,如果这段时间内再次调用,则重新计算 在一定的时间间隔内,将多次触发变成一次触发. 防抖应用场景: // setTimeout
Scroll事件滚动触发 // 停止滚动后,判断是否到达页面底部 搜索框输入查询 表单验证 按钮提交事件 浏览器窗口缩放,resize事件 节流: 持续的触发事件,每隔一段时间, 只执行一次; 减少一段时间的触发频率 // 时间戳,定时器
时间戳写法 第一次立即执行 定时器写法 第一次不执行, 最后一次执行 合并 第一次进入立即执行,最后一次也执行 应用
DOM元素的拖拽功能实现,每个一秒干嘛干嘛 射击游戏类,每隔一秒射击 计算鼠标移动距离 监听scroll滚动事件 防抖函数 debounce 1. 普通版本  function debounce(func,delay){ let timerId return function(){ // 每次点击的时候,清楚上一个定时器,重新计时 clearTimeout(timerId) timerId = setTimeout(() => { func.apply(this,arguments) // 如果setTimeout不是箭头函数 }, delay); } } // https://www.30secondsofcode.org/js/s/debounce const debounce = (fn, ms = 0) => { let timeoutId; return function(.</div></section><section class=item><div><h1 class=title><a href=/posts/2021-02-28-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9B%B8%E5%85%B3/>EventLoop事件循环</a></h1><div class=date>Feb 28, 2021</div></div><div class=summary>为什么JavaScript是单线程的? JavaScript是一门单线程非阻塞的脚本语言, 作为浏览器脚本语言,JavaScript的主要用途是与用户互动，以及操作DOM。
这决定了它只能是单线程，就是同一时间只能做一件事情，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器就不知道以哪个为准了.
任务队列 (Event Queue) 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但这样就太浪费资源了.
怎么解决呢? JS主线程挂起处于等待中的任务, 先运行后面的任务, 再在适当的时候执行这些挂起的任务.
于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
同步任务: 立即执行的任务, 同步任务一般会直接进入到主线程中执行. 只有前一个任务执行完毕，才能执行后一个任务； 异步任务: 异步执行的任务,不进入主线程、而进入"任务队列"（task queue）的任务，如, Ajax网络请求,seTtimeout等定时函数, 异步任务会通过任务队列的机制(先进先出的机制)来进行协调.
事件和回调函数 “任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列”，就是读取里面有哪些事件。
“任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列”，等待主线程读取。
所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。
“任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，“任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。
事件循环 Event Loop 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）
同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空后，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。
在事件循环中，每进行一次循环操作称为tick
http://latentflip.com/loupe/ 栈是一种结构化的内存，遵循LIFO（先进后出）的原则 队列也是一种结构化的内存，遵循FIFO（先进先出）的原则
宏任务:
script( 整体代码)、为什么?? setTimeout、 setInterval、 I/O、 UI Render setImmediate(Node.js 环境) 微任务:
promise.then() || catch() Async/Await(实际就是promise) MutaionObserver() process.nextTick(Node.js 环境) 执行一个宏任务–>清空微任务–>UI Render ==> 执行一个宏任务–>清空微任务–>UI Render (UI Render不一定执行, 是否有UI变动)</div></section><section class=item><div><h1 class=title><a href=/posts/hexo-github-pages%E6%90%AD%E5%BB%BAblog/>Hexo+Github Pages搭建blog</a></h1><div class=date>Feb 25, 2021</div></div><div class=summary>安装Hexo https://hexo.io/zh-cn/docs/
npm install hexo 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。
$ hexo init &lt;folder> $ cd &lt;folder> $ npm install 启动服务
$ hexo g // hexo generate 生成静态文件 $ hexo s // 启动本地预览服务 修改主题为Next主题 安装主题 Using Git 推荐,可修改模板文件 $ cd hexo-site $ git clone https://github.com/next-theme/hexo-theme-next themes/next Using npm 安装后Theme文件夹下没有主题文件 $ cd hexo-site $ npm install hexo-theme-next 配置主题 hexo/_config.yml theme: next Next文档 https://theme-next.js.org/docs/getting-started/
去掉 Powered by 信息 /themes/(你的主题)/layout/_partials/footer.***
{%- if theme.footer.powered %} &lt;div class="powered-by"> {%- set next_site = 'https://theme-next.</div></section></div><div class="section narrow"><div class=footer-hr></div><div class=footer-container><div class=footer-text>© 2021 Zxd's Blog</div><div class=social-icon-outer><div class=social-icon-container></div></div></div></div></div><script src=/js/prism.js></script></body></html>