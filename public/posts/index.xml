<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zxd&#39;s Blog</title>
    <link>http://zxdfe.github.io/posts/</link>
    <description>Recent content in Posts on Zxd&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Mar 2021 00:57:19 +0800</lastBuildDate><atom:link href="http://zxdfe.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Helloworld</title>
      <link>http://zxdfe.github.io/posts/helloworld/</link>
      <pubDate>Fri, 12 Mar 2021 00:57:19 +0800</pubDate>
      
      <guid>http://zxdfe.github.io/posts/helloworld/</guid>
      <description>go Blog demo测试一下
哈哈 function(){ console.log(&amp;#34;hello world&amp;#34;)console.log(&amp;#34;hello world&amp;#34;)console.log(&amp;#34;hello world&amp;#34;)console.log(&amp;#34;hello world&amp;#34;)console.log(&amp;#34;hello world&amp;#34;)console.log(&amp;#34;hello world&amp;#34;)console.log(&amp;#34;hello world&amp;#34;) } </description>
    </item>
    
    <item>
      <title>深浅拷贝</title>
      <link>http://zxdfe.github.io/posts/2021-03-05-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Fri, 05 Mar 2021 16:45:33 +0000</pubDate>
      
      <guid>http://zxdfe.github.io/posts/2021-03-05-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>拷贝一个很多嵌套的对象怎么实现? 写成怎样的深拷贝才算合格  浅拷贝 创建一个新的对象，来接受要重新复制或引用的对象值。 (只能复制一层)
 如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象； 如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，就会影响另一个对象  1. Object.assign() 用于对象的合并 **Object.assign()**** **将源对象（source）的所有可枚举属性，复制到目标对象（target）。它将返回目标对象。 ES6中object的一个方法, 第一个参数是拷贝的目标对象, 后面的参数是拷贝的来源对象(也可以是多个来源) Object.assign(target,...sources)
let target = {} let source = { a: { b : 1 }} Object.assign(target, source) console.log(target) // {a: {b: 1}}  const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // expected output: Object { a: 1, b: 4, c: 5 }  console.</description>
    </item>
    
    <item>
      <title>防抖和节流</title>
      <link>http://zxdfe.github.io/posts/2021-03-03-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</link>
      <pubDate>Wed, 03 Mar 2021 23:46:09 +0000</pubDate>
      
      <guid>http://zxdfe.github.io/posts/2021-03-03-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</guid>
      <description>防抖与节流应用场景 防抖: 事件响应函数(doSomething)在一段时间后(300ms)才执行,如果这段时间内再次调用,则重新计算 在一定的时间间隔内,将多次触发变成一次触发. 防抖应用场景: // setTimeout
 Scroll事件滚动触发 // 停止滚动后,判断是否到达页面底部 搜索框输入查询 表单验证 按钮提交事件 浏览器窗口缩放,resize事件  节流: 持续的触发事件,每隔一段时间, 只执行一次; 减少一段时间的触发频率 // 时间戳,定时器
 时间戳写法 第一次立即执行 定时器写法 第一次不执行, 最后一次执行 合并 第一次进入立即执行,最后一次也执行  应用
 DOM元素的拖拽功能实现,每个一秒干嘛干嘛 射击游戏类,每隔一秒射击 计算鼠标移动距离 监听scroll滚动事件  防抖函数 debounce 1. 普通版本  function debounce(func,delay){ let timerId return function(){ // 每次点击的时候,清楚上一个定时器,重新计时  clearTimeout(timerId) timerId = setTimeout(() =&amp;gt; { func.apply(this,arguments) // 如果setTimeout不是箭头函数  }, delay); } } // https://www.30secondsofcode.org/js/s/debounce const debounce = (fn, ms = 0) =&amp;gt; { let timeoutId; return function(.</description>
    </item>
    
    <item>
      <title>EventLoop事件循环</title>
      <link>http://zxdfe.github.io/posts/2021-02-28-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sun, 28 Feb 2021 23:11:23 +0000</pubDate>
      
      <guid>http://zxdfe.github.io/posts/2021-02-28-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9B%B8%E5%85%B3/</guid>
      <description>为什么JavaScript是单线程的? JavaScript是一门单线程非阻塞的脚本语言, 作为浏览器脚本语言,JavaScript的主要用途是与用户互动，以及操作DOM。
这决定了它只能是单线程，就是同一时间只能做一件事情，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器就不知道以哪个为准了.
任务队列 (Event Queue) 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。但这样就太浪费资源了.
怎么解决呢? JS主线程挂起处于等待中的任务, 先运行后面的任务, 再在适当的时候执行这些挂起的任务.
于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
同步任务: 立即执行的任务, 同步任务一般会直接进入到主线程中执行. 只有前一个任务执行完毕，才能执行后一个任务； 异步任务: 异步执行的任务,不进入主线程、而进入&amp;quot;任务队列&amp;quot;（task queue）的任务，如, Ajax网络请求,seTtimeout等定时函数, 异步任务会通过任务队列的机制(先进先出的机制)来进行协调.
事件和回调函数 &amp;ldquo;任务队列&amp;quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&amp;quot;任务队列&amp;quot;中添加一个事件，表示相关的异步任务可以进入&amp;quot;执行栈&amp;quot;了。主线程读取&amp;quot;任务队列&amp;rdquo;，就是读取里面有哪些事件。
&amp;ldquo;任务队列&amp;quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入&amp;quot;任务队列&amp;rdquo;，等待主线程读取。
所谓&amp;quot;回调函数&amp;quot;（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。
&amp;ldquo;任务队列&amp;quot;是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，&amp;ldquo;任务队列&amp;quot;上第一位的事件就自动进入主线程。但是，由于存在后文提到的&amp;quot;定时器&amp;quot;功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。
事件循环 Event Loop 主线程从&amp;quot;任务队列&amp;quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）
同步和异步任务分别进入不同的执行环境，同步的进入主线程，即主执行栈，异步的进入任务队列。主线程内的任务执行完毕为空后，会去任务队列读取对应的任务，推入主线程执行。 上述过程的不断重复就是我们说的 Event Loop (事件循环)。
在事件循环中，每进行一次循环操作称为tick
http://latentflip.com/loupe/ 栈是一种结构化的内存，遵循LIFO（先进后出）的原则 队列也是一种结构化的内存，遵循FIFO（先进先出）的原则
宏任务:
 script( 整体代码)、为什么?? setTimeout、 setInterval、 I/O、 UI Render setImmediate(Node.js 环境)  微任务:
 promise.then() || catch() Async/Await(实际就是promise) MutaionObserver() process.nextTick(Node.js 环境)  执行一个宏任务&amp;ndash;&amp;gt;清空微任务&amp;ndash;&amp;gt;UI Render ==&amp;gt; 执行一个宏任务&amp;ndash;&amp;gt;清空微任务&amp;ndash;&amp;gt;UI Render (UI Render不一定执行, 是否有UI变动)</description>
    </item>
    
    <item>
      <title>基于Hexo&#43;Github Pages搭建blog</title>
      <link>http://zxdfe.github.io/posts/%E5%9F%BA%E4%BA%8Ehexo-github-pages%E6%90%AD%E5%BB%BAblog/</link>
      <pubDate>Thu, 25 Feb 2021 23:34:03 +0000</pubDate>
      
      <guid>http://zxdfe.github.io/posts/%E5%9F%BA%E4%BA%8Ehexo-github-pages%E6%90%AD%E5%BB%BAblog/</guid>
      <description>安装Hexo https://hexo.io/zh-cn/docs/
npm install hexo 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。
$ hexo init &amp;lt;folder&amp;gt; $ cd &amp;lt;folder&amp;gt; $ npm install 启动服务
$ hexo g // hexo generate 生成静态文件 $ hexo s // 启动本地预览服务 修改主题为Next主题 安装主题 Using Git 推荐,可修改模板文件 $ cd hexo-site $ git clone https://github.com/next-theme/hexo-theme-next themes/next Using npm 安装后Theme文件夹下没有主题文件 $ cd hexo-site $ npm install hexo-theme-next 配置主题 hexo/_config.yml theme: next Next文档 https://theme-next.js.org/docs/getting-started/
去掉 Powered by 信息 /themes/(你的主题)/layout/_partials/footer.***
{%- if theme.footer.powered %} &amp;lt;div class=&amp;#34;powered-by&amp;#34;&amp;gt; {%- set next_site = &amp;#39;https://theme-next.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://zxdfe.github.io/posts/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zxdfe.github.io/posts/readme/</guid>
      <description>进阶 JS相关  防抖节流 深浅拷贝 EventLoop  CSS </description>
    </item>
    
  </channel>
</rss>
