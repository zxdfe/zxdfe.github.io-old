<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>为什么很多编程语言数组下标从0开始 - Zxd's Blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="zxd"><meta name=description content="数组 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 1. 线性表(Linear List) 线性表就是数据排成"><meta name=keywords content="Hugo,theme,Zxd"><meta name=generator content="Hugo 0.81.0 with theme even"><link rel=canonical href=http://localhost:1313/algo/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css rel=stylesheet><link href=/sass/main.min.32c3dbabfaeda2a5cbf4664abb1bb907607c45d851ac9b1eee4b0bfaaa82eb68.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="为什么很多编程语言数组下标从0开始"><meta property="og:description" content="数组 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 1. 线性表(Linear List) 线性表就是数据排成"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/algo/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87%E4%BB%8E0%E5%BC%80%E5%A7%8B/"><meta property="article:section" content="algo"><meta property="article:published_time" content="2021-05-12T21:33:44+08:00"><meta property="article:modified_time" content="2021-05-12T21:33:44+08:00"><meta itemprop=name content="为什么很多编程语言数组下标从0开始"><meta itemprop=description content="数组 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 1. 线性表(Linear List) 线性表就是数据排成"><meta itemprop=datePublished content="2021-05-12T21:33:44+08:00"><meta itemprop=dateModified content="2021-05-12T21:33:44+08:00"><meta itemprop=wordCount content="3039"><meta itemprop=keywords content="算法,数组,"><meta name=twitter:card content="summary"><meta name=twitter:title content="为什么很多编程语言数组下标从0开始"><meta name=twitter:description content="数组 数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 1. 线性表(Linear List) 线性表就是数据排成"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>zxd's blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/vue/><li class=mobile-menu-item>Vue</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/algo/><li class=mobile-menu-item>Algo</li></a><a href=/c++/><li class=mobile-menu-item>C++</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>zxd's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/vue/>Vue</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/algo/>Algo</a></li><li class=menu-item><a class=menu-item-link href=/c++/>C++</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>为什么很多编程语言数组下标从0开始</h1><div class=post-meta><span class=post-time>2021-05-12</span>
<span class=more-meta>3039 words</span>
<span class=more-meta>7 mins read</span></div></header><div class=post-toc id=post-toc><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#数组>数组</a><ul><li><a href=#1-线性表linear-list>1. 线性表(Linear List)</a></li><li><a href=#2-连续的内存空间和相同类型的数据>2. 连续的内存空间和相同类型的数据</a></li></ul></li><li><a href=#数组是如何实现根据下标随机访问数组元素的>数组是如何实现根据下标随机访问数组元素的？</a></li><li><a href=#数组和链表的区别>数组和链表的区别</a></li><li><a href=#低效的插入和删除>低效的插入和删除</a><ul><li><a href=#数组的插入>数组的插入</a></li><li><a href=#无序数组的插入>无序数组的插入</a></li><li><a href=#删除操作>删除操作</a></li></ul></li><li><a href=#警惕数组的访问越界问题>警惕数组的访问越界问题</a></li><li><a href=#容器能否完全替代数组>容器能否完全替代数组？</a></li><li><a href=#解答开篇>解答开篇</a><ul><li><a href=#减少一次减法指令>减少一次减法指令</a></li><li><a href=#历史原因>历史原因</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#ps>PS</a><ul><li><a href=#jvm标记清楚算法>JVM标记清楚算法</a></li><li><a href=#二维数组内存寻址>二维数组内存寻址：</a></li></ul></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=数组>数组</h2><blockquote><p>数组（Array）是一种<strong>线性表数据结构</strong>。它用一组<strong>连续的内存空间</strong>，来存储一组具有<strong>相同类型的数据</strong>。</p></blockquote><h3 id=1-线性表linear-list>1. 线性表(Linear List)</h3><p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。</p><ul><li>其实除了<code>数组</code>，<code>链表、队列、栈</code>等也是线性表结构。</li></ul><p><img src=https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg#w60 alt></p><p><strong>非线性表</strong></p><p><code>二叉树</code>、<code>堆</code>、<code>图</code>等。之所以叫非线性，是因为，<code>在非线性表中，数据之间并不是简单的前后关系</code>。</p><p><img src=https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg#w60 alt></p><h3 id=2-连续的内存空间和相同类型的数据>2. 连续的内存空间和相同类型的数据</h3><ul><li><p>正因为这两个限制，它才有了一个堪称“杀手锏”的特性：<code>随机访问</code>。</p></li><li><p>但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中<code>删除、插入</code>一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p></li></ul><h2 id=数组是如何实现根据下标随机访问数组元素的>数组是如何实现根据下标随机访问数组元素的？</h2><p>拿长度为10的int类型数组 <code>int[] a = new int[10]</code> 举例, 计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><p><img src=https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg#w60 alt></p><p>我们知道, 计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。</p><p>当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>a[i]_address = base_address + i * data_type_size
</code></pre></td></tr></table></div></div><ul><li>data_type_size 表示数组中每个元素的大小,这个例子中,数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节</li><li>base-address 当前例子 1000</li></ul><h2 id=数组和链表的区别>数组和链表的区别</h2><ul><li>表述不准确: <code>“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)"</code></li></ul><p>数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)</p><ul><li>正确表述: <code>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</code></li></ul><h2 id=低效的插入和删除>低效的插入和删除</h2><h3 id=数组的插入>数组的插入</h3><ul><li>在数组开头插入元素,那所有的数据都需要依次往后移动一位,最坏时间复杂度 O(n)</li><li>数组末尾插入元素,不需要移动数据 O(1)</li><li>因为我们在每个位置插入元素的概率是一样的，所以<code>平均情况时间复杂度</code>为 (1+2+&mldr;n)/n=<code>O(n)</code>。</li></ul><h3 id=无序数组的插入>无序数组的插入</h3><ul><li>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据,</li><li>如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</li></ul><p><img src=https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg#w60 alt></p><p><code>在特定场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)</code>。这个处理思想在快排中也会用到</p><h3 id=删除操作>删除操作</h3><p>和插入类似,如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><p>在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们<code>将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢</code>？</p><p>例如:数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><p><img src=https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg#w60 alt></p><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>如果你了解 JVM，你会发现，这不就是 <code>JVM 标记清除垃圾回收算法的核心思想</code>吗？没错，数据结构和算法的魅力就在于此，<code>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</code>。</p><h2 id=警惕数组的访问越界问题>警惕数组的访问越界问题</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>argv</span><span class=p>[]){</span>
    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
    <span class=k>for</span><span class=p>(;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
        <span class=n>arr</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;hello world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></td></tr></table></div></div><p>你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”，这是为什么呢？</p><p>因为，<code>数组大小为 3，a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3]访问越界</code>。</p><p>在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。根据我们前面讲的数组寻址公式，<code>a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环</code>。</p><p>数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，<code>访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误</code>。</p><h2 id=容器能否完全替代数组>容器能否完全替代数组？</h2><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 <code>ArrayList</code>、C++ STL 中的 <code>vector</code>。</p><p>拿 Java 语言来举例。如果你是 Java 工程师，几乎天天都在用 ArrayList, 那它与数组相比，到底有哪些优势呢？</p><p>ArrayList 最大的优势就是<code>可以将很多数组操作的细节封装起来</code>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<code>支持动态扩容</code>。</p><p>数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。</p><p>如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间<code>自动扩容为 1.5 倍</code>大小。</p><p>因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好在创建 ArrayList 的时候事先指定数据大小。</p><h2 id=解答开篇>解答开篇</h2><p>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</p><h3 id=减少一次减法指令>减少一次减法指令</h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>a[k]_address = base_address + k * type_size
</code></pre></td></tr></table></div></div><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>a[k]_address = base_address + (k-1)*type_size
</code></pre></td></tr></table></div></div><p>对比两个公式，我们不难发现，<code>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令</code>。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><h3 id=历史原因>历史原因</h3><p>C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p><h2 id=总结>总结</h2><blockquote><p>数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。</p></blockquote><h2 id=ps>PS</h2><h3 id=jvm标记清楚算法>JVM标记清楚算法</h3><p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。</p><p>不足：</p><ul><li>1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。</li><li>2.空间问题。会产生不连续的内存空间碎片。</li></ul><h3 id=二维数组内存寻址>二维数组内存寻址：</h3><p>对于 m * n 的数组，a [ i ][ j ] (i &lt; m,j &lt; n)的地址为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-fallback data-lang=fallback>address = base_address + ( i * n + j) * type_size
</code></pre></td></tr></table></div></div></div><footer class=post-footer><div class=post-tags><a href=/tags/%E7%AE%97%E6%B3%95/>算法</a>
<a href=/tags/%E6%95%B0%E7%BB%84/>数组</a></div><nav class=post-nav><a class=next href=/algo/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/><span class="next-text nav-default">2 两数相加</span>
<span class="next-text nav-mobile">Next</span>
<i class="fa fa-long-arrow-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=copyright><span class=copyright-year>&copy;
2020 -
2021<span class=heart>
<i class="fa fa-heartbeat"></i></span><span class=z-author>zxd</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script></body></html>