<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>TCP UDP - Zxd's Blog</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content="no-transform"><meta http-equiv=cache-control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="zxd"><meta name=description content="🎃计算机网络结构 应用层 (application layer) 应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信"><meta name=keywords content="Hugo,theme,Zxd"><meta name=generator content="Hugo 0.81.0 with theme even"><link rel=canonical href=http://localhost:1313/post/2021-12-09-tcp-udp/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link href=https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css rel=stylesheet><link href=/sass/main.min.8eca1510e0bf04006a123f0d7fcb8799b6e77ab2f264b44357a16e783b064b04.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><meta property="og:title" content="TCP UDP"><meta property="og:description" content="🎃计算机网络结构 应用层 (application layer) 应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/post/2021-12-09-tcp-udp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-12-09T00:04:11+08:00"><meta property="article:modified_time" content="2021-12-09T00:04:11+08:00"><meta itemprop=name content="TCP UDP"><meta itemprop=description content="🎃计算机网络结构 应用层 (application layer) 应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信"><meta itemprop=datePublished content="2021-12-09T00:04:11+08:00"><meta itemprop=dateModified content="2021-12-09T00:04:11+08:00"><meta itemprop=wordCount content="8030"><meta itemprop=keywords content=","><meta name=twitter:card content="summary"><meta name=twitter:title content="TCP UDP"><meta name=twitter:description content="🎃计算机网络结构 应用层 (application layer) 应用层是体系结构中的最高层。应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>zxd's blog</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>Home</li></a><a href=/post/><li class=mobile-menu-item>Archives</li></a><a href=/vue/><li class=mobile-menu-item>Vue</li></a><a href=/tags/><li class=mobile-menu-item>Tags</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>zxd's blog</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>Home</a></li><li class=menu-item><a class=menu-item-link href=/post/>Archives</a></li><li class=menu-item><a class=menu-item-link href=/vue/>Vue</a></li><li class=menu-item><a class=menu-item-link href=/tags/>Tags</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>TCP UDP</h1><div class=post-meta><span class=post-time>2021-12-09</span>
<span class=more-meta>8030 words</span>
<span class=more-meta>17 mins read</span></div></header><div class=post-toc id=post-toc><div class="post-toc-content always-active"><nav id=TableOfContents><ul><li><ul><li><a href=#计算机网络结构>🎃计算机网络结构</a><ul><li><a href=#应用层-application-layer>应用层 (application layer)</a></li><li><a href=#运输层-transport-layer>运输层 (transport layer)</a></li><li><a href=#网络层-network-layer>网络层 (network layer)</a></li><li><a href=#数据链路层data-link-layer>数据链路层(data link layer)</a></li><li><a href=#物理层physical-layer>物理层（physical layer）</a></li></ul></li><li><a href=#tcp--ip的体系结构>TCP / IP的体系结构</a></li><li><a href=#tcp和udp>TCP和UDP</a><ul><li></li><li><a href=#tcp的特点>🌝TCP的特点</a></li><li><a href=#tcp的连接>TCP的连接</a></li><li><a href=#tcp报文段首部格式>TCP报文段首部格式</a></li><li><a href=#tcp-可靠传输的工作原理>TCP 可靠传输的工作原理</a></li></ul></li><li><a href=#tcp可靠传输的实现>🤣TCP可靠传输的实现</a><ul><li></li></ul></li><li><a href=#tcp的流量控制>TCP的流量控制</a></li><li><a href=#tcp的拥塞控制>TCP的拥塞控制</a></li><li><a href=#tcp的运输连接管理>TCP的运输连接管理</a><ul><li><a href=#tcp的连接建立>TCP的连接建立</a></li><li><a href=#tcp-连接的释放>TCP 连接的释放</a></li><li><a href=#tcp的有限状态机>TCP的有限状态机</a></li></ul></li><li><a href=#http>HTTP</a><ul><li><a href=#http报文结构>HTTP报文结构</a></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></div><div class=post-content><h2 id=计算机网络结构>🎃计算机网络结构</h2><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207121853.png alt=image-20211207121853382 style=zoom:67%></p><h3 id=应用层-application-layer>应用层 (application layer)</h3><p>应用层是体系结构中的最高层。应用层的任务是<code>通过应用进程间的交互来完成特定网络应用</code>。应用层协议定义的是<strong>应用进程间通信和交互的规则</strong>。这里的<strong>进程</strong>指主机中<strong>正在运行的程序</strong>。</p><p>在互联网中应用层协议很多：如<strong>域名系统DNS、HTTPS协议、支持电子邮件的SMTP协议</strong>等。</p><p>我们把应用层交互的数据单元称为<strong>报文（message）</strong></p><h3 id=运输层-transport-layer>运输层 (transport layer)</h3><p>运输层的任务是负责<strong>两台主机中进程之间的通信</strong>提供<strong>通用的数据传输</strong>服务。应用进程利用该服务传送应用层报文。</p><p>运输层主要有两种协议</p><h5 id=传输控制协议-tcp-transmission-control-protocol>传输控制协议 TCP （Transmission Control Protocol）</h5><p>提供<strong>面向连接</strong>的、<strong>可靠的数据传输服务</strong>，数据传输单位是<strong>报文段</strong>（segment）</p><h5 id=用户数据报协议-udp-user-datagram-protocol>用户数据报协议 UDP （User Datagram Protocol）</h5><p>提供<strong>无连接</strong>的、<strong>尽最大努力（best-effort）<strong>的数据传输服务（不保证数据传输的可靠性），数据传输单位是</strong>用户数据报</strong></p><h3 id=网络层-network-layer>网络层 (network layer)</h3><p>网络层负责为分组交换网上的不同<strong>主机</strong>提供通信服务。在发送数据时，网络层把运输层产生的<strong>报文段</strong>或<strong>用户数据报</strong>封装成<strong>分组</strong>或<strong>包</strong>进行传送。</p><p>在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫<strong>IP数据报</strong>，或简称<strong>数据报</strong>。（注意区别<strong>用户数据报协议UDP</strong>）</p><p>无论在哪一层传送的数据单元，都可笼统地用**“分组**”表示</p><p>网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</p><p>互联网使用的网络层协议是无连接的网际协议IP（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong></p><h3 id=数据链路层data-link-layer>数据链路层(data link layer)</h3><p>简称<strong>链路层</strong>。在练歌相邻结点之间传送数据时，数据链路层将网络层交下来的<strong>IP数据报组装成帧（framing</strong>），在两个相邻结点间的链路上传送<strong>帧（frame</strong>）。每一帧包括<strong>数据和必要的控制信息</strong>（如同步信息、地址信息、差错控制等）。</p><p><strong>控制信息</strong>还使接收端能检测到所收到的帧中有无差错。（数据链路层不仅要检错，而且要纠错）</p><h3 id=物理层physical-layer>物理层（physical layer）</h3><p>在物理层上所传送数据的单位是<strong>比特</strong>。发送方发送1时，接收方应当收到1而不是0。因此物理层要考虑用多大的电压代表1或0，以及接收方如何识别发送方所发送的比特。</p><p>注意，传递信息所利用的一些物理媒介，如双绞线、同轴电缆、光缆、无线信道，并不在物理层协议之内而是在物理层协议下面。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207150728.png alt=image-20211207150728364 style=zoom:67%></p><h2 id=tcp--ip的体系结构>TCP / IP的体系结构</h2><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207151112.png alt=image-20211207151111950 style=zoom:50%></p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207151148.png alt=image-20211207151148773 style=zoom:50%></p><p>这种很像沙漏计时器形状的TCP/IP协议族表明：</p><p>TCP/IP协议<strong>可以为各式各样的应用提供服务（everthing over IP）</strong>, 同时TCP/IP协议也<strong>允许IP协议在各式各样的网络构成的互联网上运行（IP over everything）</strong>。</p><p>从中不难看出IP协议在互联网中的核心作用。</p><h2 id=tcp和udp>TCP和UDP</h2><p>TCP和UDP都属于运输层。</p><h4 id=udp的特点>🌝UDP的特点</h4><h5 id=1-udp是无连接的>1. UDP是无连接的</h5><p>即发送数据前不需要建立连接，因此减少了开销和发送数据之前的时延。</p><h5 id=2-udp使用尽最大努力交互不可靠性>2. UDP使用尽最大努力交互（不可靠性）</h5><p>即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p><h5 id=3-udp是面向报文的>3. UDP是面向报文的</h5><p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。</p><p>UDP对应用层交下来的报文，既不合并，也不拆分，而是<strong>保留这些报文的边界</strong>。也就是说，应用层交给UDP多长的报文，UDP就照样发送，<strong>UDP一次交付一个完整的报文</strong>。因此，应用程序必须选择合适大小的报文。</p><p>若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。</p><h5 id=4-udp没有拥塞控制>4. UDP没有拥塞控制</h5><p>因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用很重要。很多实时应用（如IP电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发送拥塞时丢失一些数据，但却不允许数据有太大的时延。</p><h5 id=5-udp支持一对一一对多多对一多对多的交互通信>5. UDP支持一对一、一对多、多对一、多对多的交互通信</h5><h5 id=6-udp首部开销小>6. UDP首部开销小</h5><p>UDP首部只有8个字节，比TCP的20个字节首部要短。</p><h3 id=tcp的特点>🌝TCP的特点</h3><h5 id=1-tcp是面向连接的运输层协议><strong>1. TCP是面向连接的运输层协议</strong></h5><p>应用程序在使用TCP协议前，必须先建立TCP连接。在传送数据完毕后，必须释放已经建立的TCP连接。</p><h5 id=2-每一条tcp连接只能有两个端点endpoint>2. 每一条TCP连接只能有两个端点（endpoint）</h5><p>每一条TCP连接只能是点对点的</p><h5 id=3-tcp提供可靠交付的服务>3. TCP提供可靠交付的服务</h5><p>通过TCP连接传送的数据，无差错、不丢失、不重复，并且按序到达。</p><h5 id=4-tcp提供全双工通信>4. TCP提供全双工通信</h5><h5 id=5-面向字节流>5. 面向字节流</h5><p>TCP中的<strong>流（stream）指的是流入到进程或从进程流出的字节序列</strong>。</p><p>面向字节流的含义是：</p><p>虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 <strong>TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</strong></p><p>TCP和UDP在发送报文时所采用的方式完全不同。<strong>TCP并不关心应用程序一次把多长的报文发送到TCP缓存中</strong>，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应该包含多少个字节。而UDP发送的报文长度是应用进程给出的。</p><h3 id=tcp的连接>TCP的连接</h3><p>TCP把<strong>连接作为最基本的抽象</strong>。TCP的许多特性都与TCP是面向连接的这个基本的特性有关。</p><p>每一条TCP连接有两个端点。那么，TCP连接的端点是什么呢？</p><p>TCP 连接的端点叫做<strong>套接字（socket）或插口</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-http data-lang=http><span class=err>套接字 socket = (IP地址：端口号)
</span></code></pre></td></tr></table></div></div><p><strong>每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-http data-lang=http><span class=err>TCP连接 ：：= {socket1, socket2} = {(IP1 : port1) , (IP2 : port2)}
</span></code></pre></td></tr></table></div></div><p><strong>TCP连接的端点是个很抽象的套接字，即（IP地址 ：端口号）</strong></p><p>同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中。</p><h3 id=tcp报文段首部格式>TCP报文段首部格式</h3><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208174614.png alt=image-20211208174614307 style=zoom:67%></p><p>TCP虽然是面向字节流的，但TCP传输的数据单元却是报文段。一个TCP报文段分为首部和数据两部分。</p><h4 id=首部个字段意义>首部个字段意义</h4><h5 id=1源端口和目的端口>1.源端口和目的端口</h5><p>各占2字节，分别写入源端口号和目的端口号。</p><h5 id=2-序号>2. 序号</h5><p>占4字节。序号范围[0, $2^{32}$ - 1] ， 共 $2^{32}$ 序号。TCP是面向字节流的。<strong>在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。</strong></p><h5 id=3-确认号>3. 确认号</h5><p>占4字节，是<strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-http data-lang=http><span class=err>若确认号 = N，则表明：到序号 N-1 为止的所有数据都已正确收到。
</span></code></pre></td></tr></table></div></div><h5 id=4-数据偏移>4. 数据偏移</h5><p>占4位，它指出 TCP 报文段的<strong>数据起始处</strong>距离 <strong>TCP 报文段的起始处</strong>有多远。</p><p>这个字段实际上<strong>指出 TCP 报文段的首部长度</strong>。</p><h5 id=5-保留>5. 保留</h5><p>占6位，保留为今后使用，目前置为0。</p><h5 id=6-6个控制位>6. 6个控制位</h5><h6 id=1-紧急-urgurgent>1. 紧急 URG（URGent）</h6><p>URG = 1, 表明紧急指针字段有效。比如中断命令（ctr+c）</p><h6 id=2-确认-ack-acknowledgment>2. 确认 ACK （ACKnowledgment）</h6><p>当 ACK = 1 时确认号字段才有效。当ACK = 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1.</p><h6 id=3-推送-psh-push>3. 推送 PSH （PuSH）</h6><h6 id=4-复位-rst-reset>4. 复位 RST （ReSeT）</h6><p>当 RST = 1 时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝非法报文段或拒绝打开一个连接。RST也叫重置位。</p><h6 id=5-同步-synsynchronization>5. 同步 SYN（SYNchronization）</h6><p>在连接建立时用来同步序号。</p><p>当SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1, ACK</p><p>= 1。<strong>SYN 置 1 表示这是一个连接请求或连接接受报文。</strong></p><h6 id=6-终止-fin-finis>6. 终止 FIN （FINis）</h6><p>用来释放一个连接。当FIN = 1时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。</p><h5 id=7-窗口>7. 窗口</h5><p>占 2 字节。值是 [0, 2^16 - 1]之间的整数。</p><p><strong>窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。</strong></p><p><strong>窗口字段明确指出了现在允许对方发送的数据量</strong>。 窗口值经常动态的变化着。</p><h5 id=8-校验和>8. 校验和</h5><p>占 2 字节。校验和检验的范围包括<strong>首部</strong>和<strong>数据</strong>这两部分。</p><p>检测数据传输中是否有错，有错就丢弃。</p><h5 id=9-紧急指针>9. 紧急指针</h5><p>占 2 字节。紧急指针仅在 URG = 1 时才有意义。PS. 即使窗口为零时也可发送紧急数据。</p><h5 id=10-选项>10. 选项</h5><p>长度可变，最长可达40字节。当没有使用<strong>选项</strong>时，TCP的首部长度是20字节。</p><p>（1kb是1024字节，也就是1024k）</p><h3 id=tcp-可靠传输的工作原理>TCP 可靠传输的工作原理</h3><p>我们知道，TCP发送的报文段是交给IP层传送的，但IP层只能提供尽最大努力服务，也就是说，<strong>TCP 下面的网络所提供的是不可靠的传输。</strong></p><p>理想的传输条件有以下两个特点</p><ol><li>传输信道不产生差错</li><li>不管发送方以多快的速度发送数据，接受方总来得及处理收到的数据</li></ol><p>实际网络都不具备以上两个理想条件。但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送发适当降低发送数据的速度。</p><h4 id=停止等待协议>停止等待协议</h4><p>“停止等待” 就是每发送完一个分组就停止发送，等待对方的确认。在收到对方确认后再发送下一个分组。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208202629.png alt=image-20211208202628976 style=zoom:67%></p><blockquote><p>运输层传送的协议数据单元叫<strong>报文段</strong>，网络层传送的协议数据单元叫 <strong>IP 数据报</strong>。一般讨论问题时，可以把它们简称为<strong>分组</strong></p></blockquote><p>对于出现差错的情况，可靠传输协议是这样设计的：</p><p>发送方 A 只要超过一段时间仍没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。这就叫<strong>超时重传</strong>。</p><p>要实现超时重传，就要在每发送完一个分组时设置一个<strong>超时计时器</strong>。</p><h5 id=信道利用率>信道利用率</h5><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208203452.png alt=image-20211208203452359 style=zoom:67%>
$$
U = \frac{T_D}{T_D+RTT+T_A}
$$
为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是<strong>采用流水线传输</strong>。如下，</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208205731.png alt=image-20211208205731619 style=zoom:67%></p><p>流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方确认。这样可使信道上一直有数据不间断地传送。</p><h4 id=连续arq协议>连续ARQ协议</h4><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208210643.png alt=image-20211208210642998 style=zoom:67%></p><p>发送方维持一个发送窗口，它的意义是：<strong>位于发送窗口内的分组都可以连续发送出去，而不需要等待对方的确认</strong>。</p><p>连续ARQ协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</p><p>接收方一般都是采用<strong>累积确认</strong>的方式。就是说，接收方不必对收到的分组逐个发送确认，而是收到几个分组后，<strong>对按序到达的最后一个分组发送确认</strong>。表示：到这个分组为止的所有分组都已正确收到了。</p><hr><h2 id=tcp可靠传输的实现>🤣TCP可靠传输的实现</h2><p>TCP主要提供了</p><ol><li><p><strong>校验和</strong></p></li><li><p><strong>序列号和确认应答</strong></p></li><li><p><strong>超时重传</strong></p></li><li><p><strong>流量控制（滑动窗口协议）</strong></p></li><li><p><strong>拥塞控制</strong></p><p>等保证数据的可靠传输。</p></li></ol><h4 id=1-以字节为单位的滑动窗口>1. 以字节为单位的滑动窗口</h4><p>TCP 的滑动窗口是以字节为单位的。现假定A收到了B发来的确认报文段，其中窗口是20字节，而确认号是31（表明B期望收到的下一个序号是31，序号30为止的数据已经收到了）。根据这两个数据，A就构造出自己的发送窗口。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208211245.png alt=image-20211208211245009 style=zoom:67%></p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208211453.png alt=image-20211208211453198 style=zoom:67%></p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208211529.png alt=image-20211208211529175 style=zoom:67%></p><h4 id=2-超时重传时间的选择>2. 超时重传时间的选择</h4><p>参考 计算机网络 第7版 P225</p><h4 id=3-选择确认sack>3. 选择确认SACK</h4><p>如果要使用选择确认SACK，那么在建立TCP连接时，就要在TCP首部选项中加上“允许SACK”的选项，双方必须都事先商定好。</p><p>然后，SACK文档并没有指明发送方应当怎样响应SACK。因此大多数的实现还是重传所有未被确认的数据块。</p><h2 id=tcp的流量控制>TCP的流量控制</h2><p>所谓<strong>流量控制（flow control）就是让发送发的发送速率不要太快，要让接收方来得及接收。</strong></p><p>利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208213633.png alt=image-20211208213633437 style=zoom:67%></p><p>这里rwnd表示 receiver window ： 接收方的窗口。单位是字节。表明接收方目前能接收的数据容量。</p><h2 id=tcp的拥塞控制>TCP的拥塞控制</h2><p>TCP进行拥塞控制的算法有四种：</p><ol><li><strong>慢开始 （slow-start）</strong></li><li><strong>拥塞避免 (congestion avoidance)</strong></li><li><strong>快重传 (fast retransmit)</strong></li><li><strong>快恢复 (fast recover)</strong></li></ol><p>参考 计网7版 P232</p><hr><h2 id=tcp的运输连接管理>TCP的运输连接管理</h2><p>TCP 是面向连接的协议。运输连接时用来传送TCP报文的。 TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</p><p>因此，运输连接有三个阶段：</p><pre><code>    1. **连接建立**
	2. **数据传送**
	3. **连接释放**
</code></pre><p>TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），被动等待连接建立的应用进程叫做服务器（server）。</p><h3 id=tcp的连接建立>TCP的连接建立</h3><p>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208220444.png alt=image-20211208220444882 style=zoom:67%></p><p>计网7中指出：首次采用<strong>三报文握手</strong>。 P 238</p><blockquote><p>以前该教程采用“三次握手”这个广为流行的译名。但其实这是<strong>在一次握手过程中交换了三个报文，而并不是进行了三次握手</strong>。</p><p>这有点像两个人见面进行一次握手时，他们的手上下摇晃了三次，但并非进行了三次握手。</p><p>RFC 973文档 表述：<strong>three way(three message) handshake</strong>, handshake使用的是单数，表明是一次握手。</p></blockquote><h4 id=三报文握手>🔥三报文握手</h4><ol><li>假定A运行TCP客户程序，B运行TCP服务器程序，最初两端的TCP进程都处于<strong>CLOSED</strong>（关闭）状态。</li><li>A主动打开连接，B被动打开连接</li><li>一开始，B的TCP服务器进程先<strong>创建传输控制块TCB</strong>，准备接受客户进程的连接请求。B服务器进程处于<strong>LISTEN</strong>（收听）状态，等待客户连接请求。</li><li>A的TCP 客户进程也是首先<strong>创建传输控制模块TCB</strong>。然后，在打算建立TCP连接时，向B发出连接请求报文段。<ol><li>同步位 <strong>SYN = 1</strong>，同时选择一个初始序号 <strong>seq = x</strong></li><li>TCP规定，SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗掉一个序号。</li><li>这时 TCP客户进程进入 **SYN-SENT(同步已发送)**状态</li></ol></li><li>B收到连接请求报文段后，如果同意建立连接，向A发送确认<ol><li>SYN = 1，ACK = 1，确认号 ack = x + 1, 同时也为自己选择一个初始序号 seq = y</li><li>这个报文也不能携带数据，但<strong>同样要消耗掉一个序号</strong></li><li>B服务器进程进入 **SYN-RCVD（同步收到）**状态</li></ol></li><li>A 收到 B的确认后，还要向B给出确认。<ol><li>确认报文段的 ACK = 1，确认号 ack= y + 1, 自己的序号 seq = x + 1</li><li>TCP规定，ACK报文段可以携带数据。如果不携带数据则不消耗序号，这种情况下，下一个数据报文段序号仍是seq=x+1</li><li>这时，TCP连接已经建立， A 进入 <strong>ESTABLISHED （已建立连接）状态</strong></li></ol></li><li>B收到A的确认后，也进入 <strong>ESTABLISHED （已建立连接）状态</strong></li></ol><p>以上连接建立的过程叫做 <strong>三报文握手</strong>，注意改名字了。three way handshake。</p><blockquote><p>为什么 A 最后还要发送一次确认呢？</p></blockquote><p><strong>为了防止已失效的连接请求报文段突然又传送到了B</strong>，因而产生错误。</p><p>正常情况：</p><p>A 发送连接请求，但因连接请求报文丢失而未收到确认。A 再重传一次连接请求。后来收到确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送两次连接请求报文段，第一个丢失，第二个重传到达了B。</p><p><strong>异常情况：</strong></p><p>A发送的第一个连接请求报文并没有丢失，而是在某个网络结点滞留了，以致延误到连接释放的某个时间才到达B。这本来是一个早已失效的报文段。这个时候B收到会误认为是A又发出一次新的连接请求，于是向A发出确认报文段，同意建立连接。如果不采用三次报文握手，只要B发出确认，新的连接就建立了。</p><p>然后这边A并没有发出建立连接请求，因此不会理睬B的确认。B那边却以为新的运输连接已经建立了，并一直等待A发来数据。浪费B的资料。</p><p><strong>三报文握手</strong>：</p><p>刚才的异常情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要建立连接。</p><h3 id=tcp-连接的释放>TCP 连接的释放</h3><p>数据传输结束后，通信的双方都可释放连接。现在A 和 B 都处于 <strong>ESTABLISHED （已建立连接）状态</strong></p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208230858.png alt=image-20211208230857966 style=zoom:67%></p><h4 id=四次挥手>🌝四次挥手</h4><ol><li><p>A的应用进程先向其TCP发出连接释放报文段，并停止发送数据，主动关闭TCP连接。</p><ol><li>A 把连释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u, 它等于已发送数据的最后一个字节序号+1.</li><li>A 进入 <strong>FIN-WAIT-1 (终止等待1)状态</strong>，等待B的确认</li><li>TCP规定，FIN报文段即使不携带数据，也消耗掉一个序号。</li></ol></li><li><p>B 收到连接释放报文段后发出确认。</p><ol><li>确认号 ack = u + 1, 序号 seq = v（已发送序号+1）</li><li>B进入 <strong>CLOSE-WAIT (关闭等待)状态</strong></li><li>TCP服务器进程这时应通知高层应用进程，因而A->B 这个方向的连接就释放了。</li><li>这时TCP处于 <strong>半关闭状态</strong>（half-close), 即A已经没有数据要发送了，但B若发送数据， A 仍要接收。也就是说，从B -> A这个方向的连接并未关闭，这个状态会持续一段时间</li></ol></li><li><p>A 收到来自B的确认后，进入 <strong>FIN-WAIT-2 (终止等待2)状态</strong>，等待B发出的连接释放报文段</p></li><li><p>若B已经没有要向A发送的数据，其应用进程就通知TCP释放连接。</p><ol><li>这时B发出的连接释放报文段必须使用 FIN = 1。图中，还有 ACK = 1</li><li>假定B的序号为w (在半关闭状态B可能又发送了一些数据) seq = w</li><li>B还必须重复上次已发送过的确认号 ack = u + 1</li><li>这时B 就进入 **LAST-ACK（最后确认）**状态，等待A确认</li></ol></li><li><p>A在收到B的连接释放报文段后，必须对此发出确认。</p><ol><li>在确认报文段中 ACK = 1， 确认号 ack = w + 1, 自己的序号 seq = u + 1（根据TCP标准，前面发送过的FIN报文段要消耗一个序号 所以，seq = u + 1）</li><li>然后A进入 <strong>TIME-WAIT (时间等待)状态</strong>。</li><li>此时 TCP 连接还没有释放掉。必须经过 <strong>时间等待计时器（TIME-WAIT）<strong>设置的 <strong>2MSL</strong> 后，A才进入到</strong>CLOSED状态</strong></li><li>时间MSL叫<strong>最长报文段寿命</strong>（Maximum Segment Lifetime） RFC 793建议设为2分钟。TCP允许不同的实现根据具体使用清空使用更小的MSL值。</li><li>从A进入到 TIME-WAIT状态后，要进过4分钟才能进入到 CLOSED 状态，才能开始建立下一个新连接。</li></ol></li><li><p>B 只要收到了 A发出的确认，就进入 CLOSED 状态。</p><ol><li>同样，B在撤销响应的传输控制块TCB后，就结束了这次的TCP连接。</li><li>我们注意到，B结束TCP连接的时间要比A早一些。</li></ol></li></ol><blockquote><p>为什么 A 要再 TIME-WAIT 状态必须等到2MSL的时间呢。</p></blockquote><ol><li>为了保证A发送的最后一个ACK报文段能够到达B</li><li>防止“<strong>已失效的连接请求报文段</strong>”出现在本连接中。</li></ol><p>参考： <a href=https://mp.weixin.qq.com/s/u56NcMs68sgi6uDpzJ61yw>关于 TCP 三次握手和四次挥手，满分回答在此</a></p><h3 id=tcp的有限状态机>TCP的有限状态机</h3><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211208235925.png alt=image-20211208235924886 style=zoom:67%></p><hr><h2 id=http>HTTP</h2><p>HTTP属于应用层协议，是<strong>面向事务</strong>（transaction-oriented）的。</p><p>是万维网上能够可靠地交换文件的重要基础。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207154746.png alt=image-20211207154746435 style=zoom:50%></p><p>每个万维网网点都有一个服务器进程，它不断地监听TCP的端口80，以便发现是否有浏览器向它发送连接建立请求。</p><p><strong>HTTP使用了面向连接的TCP作为运输层协议，保证了数据的可靠传输。<strong>但是</strong>HTTP协议本身是无连接</strong>的。也就是说，虽然HTTP使用了TCP连接，但通信的双方在交换HTTP报文之前是不需要先建立HTTP连接。</p><p>HTTP协议是<strong>无状态的</strong>。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的相应与第一次被访问时的相同（假定服务器还没有把该页面更新），因为服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。</p><p>当用户在点击鼠标链接按某个link时，HTTP协议首先要和服务器建立TCP链接。这需要使用三次报文握手。当建立TCP连接的三报文握手的前两部分完成后（经过了一个RTT时间），客户端就把HTTP请求报文，作为建立TCP连接三报文握手中的第三个报文的数据，发送给服务器。服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207155748.png alt=image-20211207155748559 style=zoom:50%></p><p>请求一个万维网文档所需的时间是该文档的<strong>传输时间</strong>加上<strong>两倍往返RTT</strong>。一个RTT用于建立TCP连接，另一个RTT用于请求和接受相应数据。TCP建立连接的三报文握手的第三个报文段中的数据，就是客户端对服务端的请求报文。</p><p><strong>HTTP/1.0的主要缺点，就是每请求一个文档就要有两倍RTT的开销。</strong></p><p>HTTP/1.1协议较好的解决了这个问题，它使用了持续连接（persistent conncetion）。所谓持续连接就是服务器再发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。</p><h3 id=http报文结构>HTTP报文结构</h3><p>HTTP有两类报文：</p><ul><li><p>请求报文 &ndash; 从客户向服务器发送请求报文。</p></li><li><p>响应报文 &ndash; 从服务器到客户的回答。</p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207160533.png alt=image-20211207160533029 style=zoom:50%></p></li></ul><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207160643.png alt=image-20211207160643187 style=zoom:50%></p><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207160810.png alt=image-20211207160810184 style=zoom:50%></p><h4 id=请求报文>请求报文</h4><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207160844.png alt=image-20211207160844238 style=zoom:50%></p><h4 id=响应报文>响应报文</h4><p><img src=https://zxd-blog-imgs.oss-cn-beijing.aliyuncs.com/imgs/20211207161004.png alt=image-20211207161004413 style=zoom:50%></p><h4 id=cookie>Cookie</h4><p>HTTP是无状态的，但实际工作中，一些站点常常希望能够识别用户，跟踪用户状态。要做到这一点，可以在HTTP中使用Cookie，<strong>Cookie表示HTTP服务器和客户之间传递的状态信息</strong>。</p><h5 id=cookie的工作原理>cookie的工作原理</h5><p>当用户A浏览某个使用Cookie的网站时，该网站的服务器就位A产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目。接着在给A的HTTP响应报文中添加一个叫做Set-cookie的首部行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-HTTP data-lang=HTTP><span class=err>Set-cookie: 31d5d96e307aad66
</span></code></pre></td></tr></table></div></div><p>当 A 接收到这个响应时，其浏览器就在它管理的特定Cookie文件中添加一行，其中包括这个<strong>服务器的主机名</strong>和<strong>Set-cookie后面给出的识别码</strong>。当 A 继续浏览这个网站时，每发送一个 HTTP 请求报文， 其浏览器就会从其Cookie文件中取出这个网站的识别码，并放到HTTP请求报文的Cookie首部行中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-http data-lang=http><span class=err>Cookie: 31d5d96e307aad66
</span></code></pre></td></tr></table></div></div><p>于是，这个网站就能跟踪用户<code>31d5d96e307aad66</code>（用户A）在该网站的活动。</p><h2 id=参考>参考</h2><ol><li>计算机网络 第7版 谢希仁</li><li><a href=https://juejin.cn/post/6916073832335802382>原来 TCP 为了保证可靠传输做了这么多</a></li></ol></div><footer class=post-footer><div class=post-tags><a href=/tags//></a></div><nav class=post-nav><a class=prev href=/post/dns/><i class="fa fa-long-arrow-left"></i><span class="prev-text nav-default">DNS</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/2021-12-05-%E6%9F%AF%E9%87%8C%E5%8C%96curry/><span class="next-text nav-default">柯里化Curry</span>
<span class="next-text nav-mobile">Next</span>
<i class="fa fa-long-arrow-right"></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=copyright><span class=copyright-year>&copy;
2020 -
2021<span class=heart>
<i class="fa fa-heartbeat"></i></span><span class=z-author>zxd</span></span></div></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script type=text/javascript src=/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js></script><script>if(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));else{const a=document.createElement("style"),b=`
                    @media screen and (min-width: 750px){
                            img[src*="#w90"] {
                            width: 90% !important;
                            }
                            
                            img[src*="#w80"] {
                            width: 80% !important;
                            }
                            
                            img[src*="#w70"] {
                            width: 70% !important;
                            }
                            
                            img[src*="#w60"] {
                            width: 60% !important;
                            }
                            
                            img[src*="#w50"] {
                            width: 50% !important;
                            }
                            
                            img[src*="#w40"] {
                            width: 40% !important;
                            }
                            img[src*="#w30"] {
                            width: 30% !important;
                            }
                        }
                    `;try{a.appendChild(document.createTextNode(b))}catch(c){a.styleSheet.cssText=b}document.getElementsByTagName("head")[0].appendChild(a)}</script></body></html>